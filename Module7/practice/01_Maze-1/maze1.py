# Выверите и скопируйте сюда наиболее подходяший алгоритм для работы с графом(bfs/dfs)

# Опишите список смежности по изображению лабиринта из файла task.md
graph = [
    [1],           #0
    [0, 5],        #1
    [6],           #2
    [7],           #3
    [5, 8],        #4
    [1, 4],        #5
    [2, 10],       #6
    [3],           #7
    [4, 12, 9],    #8
    [8, 10],       #9
    [9, 6, 11, 14], #10
    [10],         #11
    [8],          #12
    [],           #13
    [10, 15],     #14
    [14]          #15

]

def dfs(start_point, graph):
    visited = [False] * len(graph)

    def _dfs(v):
        visited[v] = True
        for w in graph[v]:
            if not visited[w]:  # посещён ли текущий сосед?
                _dfs(w)

    _dfs(start_point)
    return visited

s1 = 0
s2 = 12
s3 = 3
f = 14

result = dfs(f, graph)


#Решите задачу и выведите ответ в нужном формате
if result[s1]:
   print(f"Из точки S1 можно дойти до финиша")
else:
   print(f"Из точки S1 нельзя дойти до финиша")

if result[s2]:
    print(f"Из точки S2 можно дойти до финиша")
else:
    print(f"Из точки S2 нельзя дойти до финиша")

if result[s3]:
    print(f"Из точки S3 можно дойти до финиша")
else:
    print(f"Из точки S3 нельзя дойти до финиша")

# Решите задачу и выведите ответ в нужном формате
